var t=Object.defineProperty,e=Object.defineProperties,n=Object.getOwnPropertyDescriptors,r=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable,c=(e,n,r)=>n in e?t(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r,o=(t,e)=>{for(var n in e||(e={}))s.call(e,n)&&c(t,n,e[n]);if(r)for(var n of r(e))a.call(e,n)&&c(t,n,e[n]);return t},i=(t,r)=>e(t,n(r));import{s as u,e as l}from"./Measurement.4181117a.js";import{I as d,J as E,K as h}from"./vendor.a2fe4dbc.js";var m={open:async function(t){return d(t,1,{upgrade:e=>e.createObjectStore(t)}).then((e=>({get:n=>e.get(t,n),put:(n,r)=>e.put(t,r,n),clear:()=>e.clear(t),keys:()=>e.getAllKeys(t)})))}};const T=t=>{throw t};let I=0;function b(t=I,e){return new Promise((n=>{t>0?setTimeout((()=>n(e)),t):n(e)}))}async function p(t,e,n){return b().then((r=>{t.run(e.createTable),t.run(e.createIndices),n&&n({done:"table",table:e.tablename})})).catch((t=>{throw new Error(`createTable "${e.tablename}"\n${t.message}`)}))}function f(t,e,n){switch(n[e]){case"string":return t?`"${t}"`:"NULL";case"number":return t?+t:"NULL";case"date":return t?new Date(t).valueOf()/1e3:"NULL";default:throw new Error("Unknown column type: {type}")}}async function y(t,e,n,r,s){return b().then((t=>async function(t,e,n){let r=n||e;return m.open(t).then((t=>t.get(r))).then((t=>t||T("not-cached"))).catch((n=>{if("not-cached"==n)return fetch(e).then((t=>t||T("not-found"))).then((t=>t.text())).then((async e=>await m.open(t).then((t=>t.put(r,e))).then((t=>e))));throw n}))}(e,r))).then((t=>function*(t,e){var n,r;const s=(null==e?void 0:e.separator)||",",a=(null==e?void 0:e.delimiter)||'"';let c=[],o=0,i=!1;for(let u=0;u<t.length;u++){let e=t.charAt(u),r=t.charAt(u+1);c[o]=c[o]||"",e==a&&i&&r==a?(c[o]+=e,u++):e!=a?e!=s||i?"\r"!=e&&"\n"!=e||i?c[o]+=e:("\r"==e&&"\n"==r&&u++,(null==(n=c[0])?void 0:n.length)>0&&(yield c),c=[],o=0):o++:i=!i}(null==(r=c[0])?void 0:r.length)>0&&(yield c)}(t))).then((t=>function(t,e,n){let r=n.next().value.map((t=>`[${t}]`)).join(", "),s=[];for(let a of n){let t=a.map(((t,n)=>f(t,n,e)));s.push("("+t.join(",")+")")}return`INSERT INTO ${t} (${r}) VALUES ${s.join(",")}`}(n.tablename,n.columnTypes,t))).then((e=>t.run(e))).then((t=>s&&s({done:"insert",table:n.tablename}))).catch((t=>{throw new Error(`insertFetchedData "${n.tablename}" "${r}"\n${t.message}"`)}))}async function R(t,e){for(let n of t){let t,r,s,a=N(this.basedir,n.tablename,e);try{t=this.db.prepare("select cachekey \n\t\t\t\tfrom cachekeys_loaded\n\t\t\t\twhere cachekey = $cachekey"),r=t.get({$cachekey:a})[0]}finally{t&&t.free()}void 0===r&&(s=this.fetchQueue.get(a),void 0===s&&(s=y(this.db,this.cachename,n,a,this.progress).then((t=>this.db.run("insert into cachekeys_loaded values ($cachekey)",{$cachekey:a}))).then((t=>this.fetchQueue.delete(a))),this.fetchQueue.set(a,s)),await s)}}function N(t,e,n){return E(t,{circuits:()=>"circuits.csv",constructors:()=>"constructors.csv",constructors_colours:()=>"constructors_colours.csv",drivers:()=>"drivers.csv",qualifying:()=>"qualifying.csv",races:()=>"races.csv",status:()=>"status.csv",results:t=>`results_${10*Math.floor(t.$year/10)}.csv`}[e](n))}function g(t,e,n,r){let s,a;try{s=t.prepare(e),a=s.getAsObject(n)}finally{s&&s.free()}return r?r(a):a}const v={tablename:"circuits",createTable:'CREATE TABLE "circuits" (\n\t"circuitId"\tINTEGER NOT NULL UNIQUE,\n\t"name"\tTEXT,\n\t"location"\tTEXT,\n\t"country"\tTEXT,\n\t"lat"\tREAL,\n\t"lng"\tREAL,\n\t"alt"\tINTEGER,\n\tPRIMARY KEY("circuitId"))',createIndices:"",columnTypes:["number","string","string","string","number","number","number"]},w=[v];async function L(t){let e={$circuitId:t};return await this.checkDependencies(w,e),g(this.db,"select *\n\tfrom circuits\n\twhere circuitId = $circuitId",e)}const A={tablename:"drivers",createTable:'CREATE TABLE "drivers" (\n\t"driverId"\tINTEGER NOT NULL UNIQUE,\n\t"number"\tINTEGER,\n\t"code"\tTEXT,\n\t"forename"\tTEXT,\n\t"surname"\tTEXT,\n\t"dob"\tINTEGER,\n\t"nationality"\tTEXT,\n\tPRIMARY KEY("driverId"))',createIndices:"",columnTypes:["number","number","string","string","string","date","string"]},G=t=>i(o({},t),{dob:new Date(1e3*t.dob)}),U=[A];async function $(t){let e={$name:t};return await this.checkDependencies(U,e),g(this.db,'select * \n\tfrom drivers \n\twhere (drivers.forename || " " || drivers.surname) \n\t\tlike $name\n\tlimit 1',e,G)}function O(t,e,n,r){let s,a=[];try{for(s=t.prepare(e),s.bind(n);s.step();){let t=s.getAsObject();a.push(r?r(t):t)}}finally{s&&s.free()}return a}const k={tablename:"races",createTable:'CREATE TABLE "races" (\n\t"raceId"\tINTEGER NOT NULL UNIQUE,\n\t"circuitId"\tINTEGER,\n\t"year"\tINTEGER,\n\t"round"\tINTEGER,\n\t"title"\tTEXT,\n\t"when"\tINTEGER,\n\tPRIMARY KEY("raceId"))',createIndices:"",columnTypes:["number","number","number","number","string","date"]},j=t=>i(o({},t),{when:new Date(1e3*t.when)}),C=[k,v];async function _(t){let e={$year:t};return await this.checkDependencies(C,e),O(this.db,"select races.*, circuits.*\n\tfrom races\n\tjoin circuits on races.circuitId = circuits.circuitId\n\twhere year = $year\n\torder by round",e,j)}const Y={tablename:"constructors_colours",createTable:'CREATE TABLE "constructors_colours" (\n\t"constructorColourId"\tINTEGER NOT NULL DEFAULT 0 UNIQUE,\n\t"constructorId"\tINTEGER,\n\t"year"\tINTEGER,\n\t"colour"\tTEXT,\n\tPRIMARY KEY("constructorColourId" AUTOINCREMENT))',createIndices:"",columnTypes:["number","number","number","string"]},q={tablename:"constructors",createTable:'CREATE TABLE "constructors" (\n\t"constructorId"\tINTEGER NOT NULL UNIQUE,\n\t"name"\tTEXT,\n\t"nationality"\tTEXT,\n\tPRIMARY KEY("constructorId"))',createIndices:"",columnTypes:["number","string","string"]},D={tablename:"results",createTable:'CREATE TABLE "results" (\n\t"resultId"\tINTEGER NOT NULL UNIQUE,\n\t"raceId"\tINTEGER,\n\t"driverId"\tINTEGER,\n\t"constructorId"\tINTEGER,\n\t"number"\tINTEGER,\n\t"grid"\tINTEGER,\n\t"position"\tINTEGER,\n\t"positionText"\tTEXT,\n\t"positionOrder"\tINTEGER,\n\t"points"\tREAL,\n\t"laps"\tINTEGER,\n\t"milliseconds"\tINTEGER,\n\t"fastestLap"\tINTEGER,\n\t"rank"\tINTEGER,\n\t"fastestLapTime"\tINTEGER,\n\t"fastestLapSpeed"\tREAL,\n\t"statusId"\tINTEGER,\n\tPRIMARY KEY("resultId"))',createIndices:'CREATE INDEX "results_idx" ON "results" (\n\t"raceId"\n)',columnTypes:["number","number","number","number","number","number","number","string","number","number","number","number","number","number","number","number","number"]},X={tablename:"status",createTable:'CREATE TABLE "status" (\n\t"statusId"\tINTEGER NOT NULL UNIQUE,\n\t"status"\tTEXT,\n\tPRIMARY KEY("statusId"))',createIndices:"",columnTypes:["number","string"]};async function M(t,e){let n={$year:t,$round:e};return await this.checkDependencies(P,n),O(this.db,Q,n,S)}const P=[A,q,Y,k,D,X],S=t=>i(o({},t),{hasFastestLap:1==t.hasFastestLap,hasSlowestLap:1==t.hasSlowestLap}),Q="select r.resultId, \n\tr.driverId, drivers.forename, drivers.surname,\n\tconstructors.name as team,\n\tconstructors_colours.colour as teamColour, \n\tstatus.status,\n\tr.grid, \n\tr.position,\n\tr.grid - r.position as positionsMoved,\n\tr.points,\n\tr.laps,\n\tr.fastestLap,\n\tr.fastestLapTime,\n\tcase when \n\t\tr.fastestLapTime = (select \n\t\t\tmin(results.fastestLapTime)\n\t\t\tfrom results \n\t\t\twhere results.raceId = r.raceId)\n\t\tthen 1\n\t\telse 0\n\t\tend as hasFastestLap,\n\tcase when \n\t\tr.fastestLapTime = (select \n\t\t\tmax(results.fastestLapTime)\n\t\t\tfrom results \n\t\t\twhere results.raceId = r.raceId\n\t\t\t\tand results.position > 0)\n\t\tthen 1\n\t\telse 0\n\t\tend as hasSlowestLap\n\tfrom results r\n\tjoin races on races.raceId = r.raceId\n\tjoin drivers on drivers.driverId = r.driverId\n\tjoin constructors on constructors.constructorId = r.constructorId\n\tjoin status on status.statusId = r.statusId\n\tleft join constructors_colours on constructors_colours.constructorColourId = (\n\t\tselect constructors_colours.constructorColourId\n\t\tfrom constructors_colours \n\t\twhere constructors_colours.constructorId = r.constructorId\n\t\tand constructors_colours.year >= $year\n\t\torder by constructors_colours.year asc\n\t\tlimit 1\n\t\t)\n\twhere races.year = $year and races.round = $round\n\torder by r.positionOrder";class H{constructor(t,e,n,r){this.checkDependencies=R,this.getCircuit=L,this.getDriverByName=$,this.getJoinedRaces=_,this.getRaceResults=M,this.db=t,this.basedir=e,this.cachename=n,this.progress=r,this.fetchQueue=new Map}}const B={locateFile:t=>`https://cdn.jsdelivr.net/npm/sql.js@1.5.0/dist/${t}`},K=[{tablename:"cachekeys_loaded",createTable:'CREATE TABLE "cachekeys_loaded" (\n\t"cachekey"\tTEXT\n\t)',createIndices:"",columnTypes:["string"]},v,Y,q,A,{tablename:"qualifying",createTable:'CREATE TABLE "qualifying" (\n\t"qualifyId"\tINTEGER NOT NULL UNIQUE,\n\t"raceId"\tINTEGER,\n\t"driverId"\tINTEGER,\n\t"constructorId"\tINTEGER,\n\t"number"\tINTEGER,\n\t"position"\tINTEGER,\n\t"q1"\tINTEGER,\n\t"q2"\tINTEGER,\n\t"q3"\tINTEGER,\n\tPRIMARY KEY("qualifyId"))',createIndices:"",columnTypes:["number","number","number","number","number","number","number","number","number"]},k,D,X];async function x(t,e,n){const r=K.length+1;let s=await h(n||B).then((t=>new t.Database)).then((t=>(e&&e({done:"database",max:r}),t)));for(let a of K)await p(s,a,e);return await async function(t,e){return fetch(e).then((t=>t||T("not-found"))).then((t=>t.json())).then((async e=>{let n=await m.open(t);return await n.get("version")!=e.version&&await n.clear(),n.put("version",e.version)})).then((t=>{}))}("f1-data",E(t,"version.json")),new H(s,t,"f1-data",e)}const F=self;let J=null;const W=new class{constructor(t){this.dispatcher=t,this.requestHandlers={}}registerHandler(t,e){if(t in this.requestHandlers)throw`ServerWorkerStub: Handler already registered for '${t}'`;this.requestHandlers[t]=e}receive(t){if(t.name in this.requestHandlers){u("ServerWorkerStub",t.id);let e=e=>this.dispatcher({id:t.id,name:"progress",data:e});this.requestHandlers[t.name](t.data,e).then((e=>this.dispatcher({id:t.id,name:"payload",data:e}))).then((()=>l("ServerWorkerStub",t.id))).catch((e=>this.dispatcher({id:t.id,name:"error",data:e})))}else this.dispatcher({id:t.id,name:"error",data:"Unknown worker message"})}}((t=>F.postMessage(t)));F.onmessage=t=>W.receive(t.data),W.registerHandler("init",(async function(t,e){if(null==J)return I=0,x(t.baseURI+"data",e).then((t=>{J=t}));throw"Database already initialised"})),W.registerHandler("getCircuit",(async t=>J.getCircuit(t.circuitId))),W.registerHandler("getJoinedRaces",(async t=>J.getJoinedRaces(t.year))),W.registerHandler("getRaceResults",(async t=>J.getRaceResults(t.year,t.round)));
