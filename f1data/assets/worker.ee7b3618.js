var __defProp=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp=(e,t,r)=>t in e?__defProp(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__spreadValues=(e,t)=>{for(var r in t||(t={}))__hasOwnProp.call(t,r)&&__defNormalProp(e,r,t[r]);if(__getOwnPropSymbols)for(var r of __getOwnPropSymbols(t))__propIsEnum.call(t,r)&&__defNormalProp(e,r,t[r]);return e},__spreadProps=(e,t)=>__defProps(e,__getOwnPropDescs(t));import{s as startMeasurement,e as endMeasurement}from"./Measurement.4181117a.js";import{I as openDB,J as urljoin,K as initSqlJs}from"./vendor.a2fe4dbc.js";class ServerWorkerStub{constructor(e){this.dispatcher=e,this.requestHandlers={}}registerHandler(e,t){if(e in this.requestHandlers)throw`ServerWorkerStub: Handler already registered for '${e}'`;this.requestHandlers[e]=t}receive(e){if(e.name in this.requestHandlers){startMeasurement("ServerWorkerStub",e.id);let t=t=>this.dispatcher({id:e.id,name:"progress",data:t});this.requestHandlers[e.name](e.data,t).then((t=>this.dispatcher({id:e.id,name:"payload",data:t}))).then((()=>endMeasurement("ServerWorkerStub",e.id))).catch((t=>this.dispatcher({id:e.id,name:"error",data:t})))}else this.dispatcher({id:e.id,name:"error",data:"Unknown worker message"})}}async function open(e){return openDB(e,1,{upgrade:t=>t.createObjectStore(e)}).then((t=>({get:r=>t.get(e,r),put:(r,n)=>t.put(e,n,r),clear:()=>t.clear(e),keys:()=>t.getAllKeys(e)})))}var KeyValStore={open:open};const error=e=>{throw e};async function maintainCache(e,t){return fetch(t).then((e=>e||error("not-found"))).then((e=>e.json())).then((async t=>{let r=await KeyValStore.open(e);return await r.get("version")!=t.version&&await r.clear(),r.put("version",t.version)})).then((e=>{}))}async function fetchFromCache(e,t,r){let n=r||t;return KeyValStore.open(e).then((e=>e.get(n))).then((e=>e||error("not-cached"))).catch((r=>{if("not-cached"==r)return fetch(t).then((e=>e||error("not-found"))).then((e=>e.text())).then((async t=>await KeyValStore.open(e).then((e=>e.put(n,t))).then((e=>t))));throw r}))}function setWaitFor(e){waitForDefault=e}let waitForDefault=0;function waitFor(e=waitForDefault,t){return new Promise((r=>{e>0?setTimeout((()=>r(t)),e):r(t)}))}async function createTable$9(e,t,r){return waitFor().then((n=>{e.run(t.createTable),e.run(t.createIndices),r&&r({done:"table",table:t.tablename})})).catch((e=>{throw new Error(`createTable "${t.tablename}"\n${e.message}`)}))}function*parseCSV(e,t){var r,n;const a=(null==t?void 0:t.separator)||",",s=(null==t?void 0:t.delimiter)||'"';let c=[],o=0,i=!1;for(let l=0;l<e.length;l++){let t=e.charAt(l),n=e.charAt(l+1);c[o]=c[o]||"",t==s&&i&&n==s?(c[o]+=t,l++):t!=s?t!=a||i?"\r"!=t&&"\n"!=t||i?c[o]+=t:("\r"==t&&"\n"==n&&l++,(null==(r=c[0])?void 0:r.length)>0&&(yield c),c=[],o=0):o++:i=!i}(null==(n=c[0])?void 0:n.length)>0&&(yield c)}function createInsertSQL(e,t,r){let n=r.next().value.map((e=>`[${e}]`)).join(", "),a=[];for(let s of r){let e=s.map(((e,r)=>columnToSQL(e,r,t)));a.push("("+e.join(",")+")")}return`INSERT INTO ${e} (${n}) VALUES ${a.join(",")}`}function columnToSQL(e,t,r){switch(r[t]){case"string":return e?`"${e}"`:"NULL";case"number":return e?+e:"NULL";case"date":return e?new Date(e).valueOf()/1e3:"NULL";default:throw new Error("Unknown column type: {type}")}}async function insertFetchedData(e,t,r,n,a){return waitFor().then((e=>fetchFromCache(t,n))).then((e=>parseCSV(e))).then((e=>createInsertSQL(r.tablename,r.columnTypes,e))).then((t=>e.run(t))).then((e=>a&&a({done:"insert",table:r.tablename}))).catch((e=>{throw new Error(`insertFetchedData "${r.tablename}" "${n}"\n${e.message}"`)}))}async function checkDependencies(e,t){for(let r of e){let e,t,n,a=getPathFor(this.basedir,r.tablename);try{e=this.db.prepare("select cachekey \n\t\t\t\tfrom cachekeys_loaded\n\t\t\t\twhere cachekey = $cachekey"),t=e.get({$cachekey:a})[0]}finally{e&&e.free()}void 0===t&&(n=this.fetchQueue.get(a),void 0===n&&(n=insertFetchedData(this.db,this.cachename,r,a,this.progress).then((e=>this.db.run("insert into cachekeys_loaded values ($cachekey)",{$cachekey:a}))).then((e=>this.fetchQueue.delete(a))),this.fetchQueue.set(a,n)),await n)}}function getPathFor(basedir,table,opts){const paths={circuits:"circuits.csv",constructors:"constructors.csv",constructors_colours:"constructors_colours.csv",drivers:"drivers.csv",qualifying:"qualifying.csv",races:"races.csv",status:"status.csv",results:"results_${Math.floor(opts.$year / 10) * 10}.csv"};return urljoin(basedir,eval("`"+paths[table]+"`"))}function getOne(e,t,r,n){let a,s;try{a=e.prepare(t),s=a.getAsObject(r)}finally{a&&a.free()}return n?n(s):s}const tablename$8="circuits",createTable$8='CREATE TABLE "circuits" (\n\t"circuitId"\tINTEGER NOT NULL UNIQUE,\n\t"name"\tTEXT,\n\t"location"\tTEXT,\n\t"country"\tTEXT,\n\t"lat"\tREAL,\n\t"lng"\tREAL,\n\t"alt"\tINTEGER,\n\tPRIMARY KEY("circuitId"))',createIndices$8="",columnTypes$8=["number","string","string","string","number","number","number"],table$8={tablename:tablename$8,createTable:createTable$8,createIndices:createIndices$8,columnTypes:columnTypes$8},stmt$3="select *\n\tfrom circuits\n\twhere circuitId = $circuitId",dependencies$3=[table$8];async function getCircuit(e){let t={$circuitId:e};return await this.checkDependencies(dependencies$3,t),getOne(this.db,stmt$3,t)}const tablename$7="drivers",createTable$7='CREATE TABLE "drivers" (\n\t"driverId"\tINTEGER NOT NULL UNIQUE,\n\t"number"\tINTEGER,\n\t"code"\tTEXT,\n\t"forename"\tTEXT,\n\t"surname"\tTEXT,\n\t"dob"\tINTEGER,\n\t"nationality"\tTEXT,\n\tPRIMARY KEY("driverId"))',createIndices$7="",columnTypes$7=["number","number","string","string","string","date","string"],table$7={tablename:tablename$7,createTable:createTable$7,createIndices:createIndices$7,columnTypes:columnTypes$7},stmt$2='select * \n\tfrom drivers \n\twhere (drivers.forename || " " || drivers.surname) \n\t\tlike $name\n\tlimit 1',mapFromSQL$2=e=>__spreadProps(__spreadValues({},e),{dob:new Date(1e3*e.dob)}),dependencies$2=[table$7];async function getDriverByName(e){let t={$name:e};return await this.checkDependencies(dependencies$2,t),getOne(this.db,stmt$2,t,mapFromSQL$2)}function getMany(e,t,r,n){let a,s=[];try{for(a=e.prepare(t),a.bind(r);a.step();){let e=a.getAsObject();s.push(n?n(e):e)}}finally{a&&a.free()}return s}const tablename$6="races",createTable$6='CREATE TABLE "races" (\n\t"raceId"\tINTEGER NOT NULL UNIQUE,\n\t"circuitId"\tINTEGER,\n\t"year"\tINTEGER,\n\t"round"\tINTEGER,\n\t"title"\tTEXT,\n\t"when"\tINTEGER,\n\tPRIMARY KEY("raceId"))',createIndices$6="",columnTypes$6=["number","number","number","number","string","date"],table$6={tablename:tablename$6,createTable:createTable$6,createIndices:createIndices$6,columnTypes:columnTypes$6},stmt$1="select races.*, circuits.*\n\tfrom races\n\tjoin circuits on races.circuitId = circuits.circuitId\n\twhere year = $year\n\torder by round",mapFromSQL$1=e=>__spreadProps(__spreadValues({},e),{when:new Date(1e3*e.when)}),dependencies$1=[table$6,table$8];async function getJoinedRaces(e){let t={$year:e};return await this.checkDependencies(dependencies$1,t),getMany(this.db,stmt$1,t,mapFromSQL$1)}const tablename$5="constructors_colours",createTable$5='CREATE TABLE "constructors_colours" (\n\t"constructorColourId"\tINTEGER NOT NULL DEFAULT 0 UNIQUE,\n\t"constructorId"\tINTEGER,\n\t"year"\tINTEGER,\n\t"colour"\tTEXT,\n\tPRIMARY KEY("constructorColourId" AUTOINCREMENT))',createIndices$5="",columnTypes$5=["number","number","number","string"],table$5={tablename:tablename$5,createTable:createTable$5,createIndices:createIndices$5,columnTypes:columnTypes$5},tablename$4="constructors",createTable$4='CREATE TABLE "constructors" (\n\t"constructorId"\tINTEGER NOT NULL UNIQUE,\n\t"name"\tTEXT,\n\t"nationality"\tTEXT,\n\tPRIMARY KEY("constructorId"))',createIndices$4="",columnTypes$4=["number","string","string"],table$4={tablename:tablename$4,createTable:createTable$4,createIndices:createIndices$4,columnTypes:columnTypes$4},tablename$3="results",createTable$3='CREATE TABLE "results" (\n\t"resultId"\tINTEGER NOT NULL UNIQUE,\n\t"raceId"\tINTEGER,\n\t"driverId"\tINTEGER,\n\t"constructorId"\tINTEGER,\n\t"number"\tINTEGER,\n\t"grid"\tINTEGER,\n\t"position"\tINTEGER,\n\t"positionText"\tTEXT,\n\t"positionOrder"\tINTEGER,\n\t"points"\tREAL,\n\t"laps"\tINTEGER,\n\t"milliseconds"\tINTEGER,\n\t"fastestLap"\tINTEGER,\n\t"rank"\tINTEGER,\n\t"fastestLapTime"\tINTEGER,\n\t"fastestLapSpeed"\tREAL,\n\t"statusId"\tINTEGER,\n\tPRIMARY KEY("resultId"))',createIndices$3='CREATE INDEX "results_idx" ON "results" (\n\t"raceId"\n)',columnTypes$3=["number","number","number","number","number","number","number","string","number","number","number","number","number","number","number","number","number"],table$3={tablename:tablename$3,createTable:createTable$3,createIndices:createIndices$3,columnTypes:columnTypes$3},tablename$2="status",createTable$2='CREATE TABLE "status" (\n\t"statusId"\tINTEGER NOT NULL UNIQUE,\n\t"status"\tTEXT,\n\tPRIMARY KEY("statusId"))',createIndices$2="",columnTypes$2=["number","string"],table$2={tablename:tablename$2,createTable:createTable$2,createIndices:createIndices$2,columnTypes:columnTypes$2};async function getRaceResults(e,t){let r={$year:e,$round:t};return await this.checkDependencies(dependencies,r),getMany(this.db,stmt,r,mapFromSQL)}const dependencies=[table$7,table$4,table$5,table$6,table$3,table$2],mapFromSQL=e=>__spreadProps(__spreadValues({},e),{hasFastestLap:1==e.hasFastestLap,hasSlowestLap:1==e.hasSlowestLap}),stmt="select r.resultId, \n\tr.driverId, drivers.forename, drivers.surname,\n\tconstructors.name as team,\n\tconstructors_colours.colour as teamColour, \n\tstatus.status,\n\tr.grid, \n\tr.position,\n\tr.grid - r.position as positionsMoved,\n\tr.points,\n\tr.laps,\n\tr.fastestLap,\n\tr.fastestLapTime,\n\tcase when \n\t\tr.fastestLapTime = (select \n\t\t\tmin(results.fastestLapTime)\n\t\t\tfrom results \n\t\t\twhere results.raceId = r.raceId)\n\t\tthen 1\n\t\telse 0\n\t\tend as hasFastestLap,\n\tcase when \n\t\tr.fastestLapTime = (select \n\t\t\tmax(results.fastestLapTime)\n\t\t\tfrom results \n\t\t\twhere results.raceId = r.raceId\n\t\t\t\tand results.position > 0)\n\t\tthen 1\n\t\telse 0\n\t\tend as hasSlowestLap\n\tfrom results r\n\tjoin races on races.raceId = r.raceId\n\tjoin drivers on drivers.driverId = r.driverId\n\tjoin constructors on constructors.constructorId = r.constructorId\n\tjoin status on status.statusId = r.statusId\n\tleft join constructors_colours on constructors_colours.constructorColourId = (\n\t\tselect constructors_colours.constructorColourId\n\t\tfrom constructors_colours \n\t\twhere constructors_colours.constructorId = r.constructorId\n\t\tand constructors_colours.year >= $year\n\t\torder by constructors_colours.year asc\n\t\tlimit 1\n\t\t)\n\twhere races.year = $year and races.round = $round\n\torder by r.positionOrder";class DataStoreImpl{constructor(e,t,r,n){this.checkDependencies=checkDependencies,this.getCircuit=getCircuit,this.getDriverByName=getDriverByName,this.getJoinedRaces=getJoinedRaces,this.getRaceResults=getRaceResults,this.db=e,this.basedir=t,this.cachename=r,this.progress=n,this.fetchQueue=new Map}}const tablename$1="cachekeys_loaded",createTable$1='CREATE TABLE "cachekeys_loaded" (\n\t"cachekey"\tTEXT\n\t)',createIndices$1="",columnTypes$1=["string"],table$1={tablename:tablename$1,createTable:createTable$1,createIndices:createIndices$1,columnTypes:columnTypes$1},tablename="qualifying",createTable='CREATE TABLE "qualifying" (\n\t"qualifyId"\tINTEGER NOT NULL UNIQUE,\n\t"raceId"\tINTEGER,\n\t"driverId"\tINTEGER,\n\t"constructorId"\tINTEGER,\n\t"number"\tINTEGER,\n\t"position"\tINTEGER,\n\t"q1"\tINTEGER,\n\t"q2"\tINTEGER,\n\t"q3"\tINTEGER,\n\tPRIMARY KEY("qualifyId"))',createIndices="",columnTypes=["number","number","number","number","number","number","number","number","number"],table={tablename:tablename,createTable:createTable,createIndices:createIndices,columnTypes:columnTypes},cachename="f1-data",defaultSqlConfig={locateFile:e=>`https://cdn.jsdelivr.net/npm/sql.js@1.5.0/dist/${e}`},tables=[table$1,table$8,table$5,table$4,table$7,table,table$6,table$3,table$2];async function createStore(e,t,r){const n=tables.length+1;let a=await initSqlJs(r||defaultSqlConfig).then((e=>new e.Database)).then((e=>(t&&t({done:"database",max:n}),e)));for(let s of tables)await createTable$9(a,s,t);return await maintainCache(cachename,urljoin(e,"version.json")),new DataStoreImpl(a,e,cachename,t)}const worker=self;let workerDb=null;const serverStub=new ServerWorkerStub((e=>worker.postMessage(e)));async function initHandler(e,t){if(null==workerDb)return setWaitFor(0),createStore(e.baseURI+"data",t).then((e=>{workerDb=e}));throw"Database already initialised"}worker.onmessage=e=>serverStub.receive(e.data),serverStub.registerHandler("init",initHandler),serverStub.registerHandler("getCircuit",(async e=>workerDb.getCircuit(e.circuitId))),serverStub.registerHandler("getJoinedRaces",(async e=>workerDb.getJoinedRaces(e.year))),serverStub.registerHandler("getRaceResults",(async e=>workerDb.getRaceResults(e.year,e.round)));
